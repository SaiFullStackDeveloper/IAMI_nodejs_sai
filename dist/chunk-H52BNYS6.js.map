{"version":3,"sources":["/Users/apple/Documents/Satya/UpW/Nodejs/iami-nodejs/dist/chunk-H52BNYS6.js","../src/common/middleware/authHandler.ts"],"names":[],"mappings":"AAAA;AACE;AACF,sDAA4B;AAC5B;AACE;AACF,sDAA4B;AAC5B;AACE;AACF,sDAA4B;AAC5B;AACE;AACF,sDAA4B;AAC5B;AACE;AACF,sDAA4B;AAC5B;AACA;ACZA,oDAA4B;AAMrB,IAAM,eAAA,EAAiB,MAAA,CAAO,GAAA,EAAc,GAAA,EAAe,IAAA,EAAA,GAAuB;AAIrF,EAAA,GAAA,CAAI,GAAA,CAAI,KAAA,IAAS,sBAAA,GAAyB,GAAA,CAAI,IAAA,CAAK,UAAA,CAAW,OAAO,CAAA,EAAG;AACpE,IAAA,OAAO,IAAA,CAAK,CAAA;AAAA,EAChB;AAEA,EAAA,MAAM,YAAA,EAAc,GAAA,CAAI,OAAA,CAAQ,mBAAmB,CAAA;AACnD,EAAA,MAAM,kBAAA,EAAoB,GAAA,CAAI,OAAA,CAAQ,aAAA;AAGtC,EAAA,GAAA,CAAI,CAAC,YAAA,GAAe,CAAC,iBAAA,EAAmB;AACpC,IAAA,OAAO,oDAAA,gCAAsB,CAAgB,OAAA;AAAA,MACzC,cAAA;AAAA,MACA,IAAA;AAAA,MACA,4BAAA,CAAY;AAAA,IAChB,CAAA,EAAG,GAAG,CAAA;AAAA,EACV;AAEA,EAAA,MAAM,YAAA,EAAc,MAAM,2CAAA,CAA2B,KAAA,CAAM,WAAW,CAAA;AAEtE,EAAA,GAAA,CAAI,CAAC,WAAA,CAAY,WAAA,EAAa;AAC1B,IAAA,OAAO,oDAAA,gCAAsB,CAAgB,OAAA;AAAA,MACzC,cAAA;AAAA,MACA,IAAA;AAAA,MACA,4BAAA,CAAY;AAAA,IAChB,CAAA,EAAG,GAAG,CAAA;AAAA,EACV;AAEA,EAAA,GAAA,CAAI,CAAA,OAAA,EAAU,WAAA,CAAY,WAAW,CAAA,EAAA;AAEJ,IAAA;AACzB,MAAA;AACA,MAAA;AACY,MAAA;AACV,IAAA;AACV,EAAA;AAEkC,EAAA;AAC7B,EAAA;AAET;AAGgE;AAIxD,EAAA;AAC0B,IAAA;AAEd,IAAA;AACsB,MAAA;AAClC,IAAA;AAEkC,IAAA;AACC,IAAA;AACD,MAAA;AAClC,IAAA;AAEsB,IAAA;AACO,IAAA;AAEF,IAAA;AACO,MAAA;AAClC,IAAA;AAKK,IAAA;AACO,EAAA;AACkB,IAAA;AAClC,EAAA;AACJ;AAG4E;AAC9C,EAAA;AACE,EAAA;AACM,IAAA;AAClC,EAAA;AAEK,EAAA;AACT;AAIwD;AAChD,EAAA;AAC+B,IAAA;AAEA,IAAA;AACG,MAAA;AAClC,IAAA;AAEoC,IAAA;AACG,IAAA;AAEjB,IAAA;AACO,IAAA;AAGF,IAAA;AACO,MAAA;AAClC,IAAA;AACK,IAAA;AACO,EAAA;AACkB,IAAA;AAClC,EAAA;AACJ;AAGkE;AACpC,EAAA;AAEd,EAAA;AACoB,IAAA;AACf,MAAA;AACG,MAAA;AACH,MAAA;AACZ,IAAA;AACL,EAAA;AAEI,EAAA;AACkC,IAAA;AACC,IAAA;AAEN,IAAA;AAED,IAAA;AACI,MAAA;AACf,QAAA;AACG,QAAA;AACH,QAAA;AACZ,MAAA;AACL,IAAA;AAEoB,IAAA;AACf,IAAA;AACO,EAAA;AACgB,IAAA;AACf,MAAA;AACG,MAAA;AACH,MAAA;AACuB,MAAA;AACnC,IAAA;AACL,EAAA;AACJ;ADlCwC;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/Users/apple/Documents/Satya/UpW/Nodejs/iami-nodejs/dist/chunk-H52BNYS6.js","sourcesContent":[null,"import { type Router, Request, Response, NextFunction } from \"express\";\nimport { userSessionRedisRepository } from \"../models/redis/user\";\nimport { handleServiceResponse } from \"../utils/httpHandlers\";\nimport { ServiceResponse } from \"../models/serviceResponse\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { UserSessionTypes } from \"../types/user\";\nimport { AccessToken } from \"../config/jwt\";\nimport { userModel } from \"../models/mongoDB/user\";\n\n// Authentication middleware\nexport const AuthMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n\n\n\n    if (req.path !== '/auth/login/refresh' && req.path.startsWith('/auth')) {\n        return next();\n    }\n\n    const emailHeader = req.headers['x-requested-email'] as string;\n    const accessTokenHeader = req.headers.authorization as string;\n\n\n    if (!emailHeader || !accessTokenHeader) {\n        return handleServiceResponse(ServiceResponse.failure(\n            \"Unauthorized\",\n            null,\n            StatusCodes.UNAUTHORIZED\n        ), res)\n    }\n\n    const userSession = await userSessionRedisRepository.fetch(emailHeader);\n\n    if (!userSession.accessToken) {\n        return handleServiceResponse(ServiceResponse.failure(\n            \"Unauthorized\",\n            null,\n            StatusCodes.UNAUTHORIZED\n        ), res)\n    }\n\n    if (`Bearer ${userSession.accessToken}` !== accessTokenHeader) {\n\n        return handleServiceResponse(ServiceResponse.failure(\n            \"Unauthorized\",\n            null,\n            StatusCodes.UNAUTHORIZED\n        ), res)\n    }\n\n    req.headers['x-requested-user'] = JSON.stringify(userSession)\n    next()\n\n};\n\n\nexport const isSuperAdmin = async (req: Request, res: Response, next: NextFunction) => {\n    // return res.status(403).json({ success: false, message: \"Access denied: Not a Super Admin\" });\n\n\n    try {\n        const token = req.headers.authorization?.split(\" \")[1];\n\n        if (!token) {\n            return res.status(401).json({ success: false, message: \"Access token missing\" });\n        }\n\n        const payload = await AccessToken(\"Decrypt\", token);\n        if (typeof payload !== \"object\" || !(\"email\" in payload)) {\n            return res.status(400).json({ success: false, message: \"Invalid token payload\" });\n        }\n\n        const email = payload.email as string;\n        const user = await userModel.findOne({ email });\n\n        if (!user || user.role !== \"SuperAdmin\") {\n            return res.status(403).json({ success: false, message: \"Access denied: Not a Super Admin\" });\n        }\n\n        // Optional: Attach user data to req.user for further usage\n        //   req.user = user;\n\n        next();\n    } catch (error) {\n        return res.status(401).json({ success: false, message: \"Invalid or expired token\" });\n    }\n};\n\n// Middleware to ensure the user is an agent\nexport const isAgent = (req: Request, res: Response, next: NextFunction) => {\n    const user = (req as any).user;\n    if (user?.role !== \"Agent\") {\n        return res.status(StatusCodes.FORBIDDEN).json({ message: \"Forbidden: Only SuperAdmin allowed.\" });\n    }\n\n    next();\n};\n\n\n\nexport const isAdminOrSuperAdmin = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n        const authHeader = req.headers.authorization;\n\n        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n            return res.status(401).json({ message: 'Unauthorized access: Missing token' });\n        }\n\n        const token = authHeader.split(' ')[1];\n        const decoded: any = await AccessToken('Decrypt', token);\n\n        const email = decoded.email as string;\n        const user = await userModel.findOne({ email });\n\n        // Allow only SuperAdmin or Employee\n        if (!user || user.role !== 'SuperAdmin' && user.role !== 'Admin') {\n            return res.status(403).json({ message: 'Access denied: Admins and SuperAdmins only have access to Edit details...' });\n        }\n        next();\n    } catch (error) {\n        return res.status(401).json({ message: 'Invalid or expired token' });\n    }\n};\n\n\nexport const isAdminOrAgent = async (req: Request, res: Response, next: NextFunction) => {\n    const token = req.headers.authorization?.split(\" \")[1];\n\n    if (!token) {\n        return res.status(401).json({\n            success: false,\n            statusCode: 401,\n            message: \"Unauthorized: No token provided\",\n        });\n    }\n\n    try {\n        const decoded = await AccessToken(\"Decrypt\", token);\n        if (!decoded || typeof decoded === \"string\") throw new Error(\"Invalid token\");\n\n        const user = await userModel.findOne({ email: decoded.email });\n\n        if (!user || (user.role !== 'Agent' && user.role !== 'Admin')) {\n            return res.status(403).json({\n                success: false,\n                statusCode: 403,\n                message: \"Forbidden: Access denied, Only Agents and Admins had the access!\"\n            });\n        }\n\n        (req as any).user = user;\n        next();\n    } catch (error) {\n        return res.status(401).json({\n            success: false,\n            statusCode: 401,\n            message: \"Unauthorized\",\n            error: error instanceof Error ? error.message : String(error)\n        });\n    }\n}"]}